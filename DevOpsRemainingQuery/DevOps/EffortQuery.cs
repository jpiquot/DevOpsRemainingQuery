namespace DevOpsRemainingQuery.DevOps
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;

    using Microsoft.TeamFoundation.WorkItemTracking.WebApi.Models;
    using Microsoft.VisualStudio.Services.WebApi;

    /// <summary>
    /// Class RemainingWorkQuery. Implements the <see cref="DevOpsRemainingQuery.DevOps.Query"/>.
    /// </summary>
    /// <seealso cref="DevOpsRemainingQuery.DevOps.Query"/>
    internal class EffortQuery : Query
    {
        private const string Activity = "Microsoft.VSTS.Common.Activity";
        private const string CompletedWork = "Microsoft.VSTS.Scheduling.CompletedWork";
        private const string OriginalEstimate = "Microsoft.VSTS.Scheduling.OriginalEstimate";
        private const string RemainingWork = "Microsoft.VSTS.Scheduling.RemainingWork";
        private const string Task = "Task";
        private const string WorkItemType = "System.WorkItemType";
        private readonly IEnumerable<string> activityOrder;
        private ActivityCollection? activityCollection;
        private WorkItemRelationType? childRelationType;
        private WorkItemRelationType? parentRelationType;

        /// <summary>
        /// Initializes a new instance of the <see cref="EffortQuery"/> class.
        /// </summary>
        /// <param name="project">The project.</param>
        /// <param name="queryName">Name of the query.</param>
        /// <param name="activityOrder">The activity order.</param>
        /// <autogeneratedoc/>
        public EffortQuery(Project project, string queryName, IEnumerable<string> activityOrder)
            : base(project, queryName)
        {
            this.activityOrder = activityOrder;
        }

        /// <summary>
        /// Gets the task field reference names.
        /// </summary>
        /// <returns>List&lt;System.String&gt;.</returns>
        public static List<string> GetTaskFieldReferenceNames()
            => new List<string>(new string[] { Activity, OriginalEstimate, RemainingWork, CompletedWork });

        /// <summary>
        /// Gets the data.
        /// </summary>
        /// <returns>QueryData.</returns>
        public override async Task<QueryData> GetData()
        {
            var fields = await GetFieldReferenceNames();
            var wis = await GetQueryWorkItems();
            var records = new List<List<object?>>(wis.Count);
            foreach (var wi in wis)
            {
                var record = new List<object?>(fields.Count);
                foreach (var field in fields)
                {
                    var value = wi.Fields.Where(p => p.Key == field).Select(p => p.Value).FirstOrDefault();
                    record.Add(value);
                }

                await AddEffortValues(record, wi);
                records.Add(record);
            }

            return new QueryData(await GetFieldNames(), records);
        }

        /// <summary>
        /// Gets the field names.
        /// </summary>
        /// <returns>List&lt;System.String&gt;.</returns>
        public override async Task<List<string>> GetFieldNames()
        {
            List<string> fieldNames = await base.GetFieldNames();
            fieldNames.AddRange(new string[] { "Total Estimated", "Total Remaining", "Total Completed" });
            foreach (var activity in (activityCollection ?? await GetOrderedActivityList()).Activities)
            {
                fieldNames.AddRange(new string[] { activity + " Original Estimate", activity + " Remaining", activity + " Completed" });
            }

            return fieldNames;
        }

        /// <summary>
        /// Adds the effort values.
        /// </summary>
        /// <param name="record">The record.</param>
        /// <param name="workItem">The work item.</param>
        /// <returns>Task.</returns>
        /// <exception cref="VssResourceNotFoundException">Query not found : " + queryName.</exception>
        private async Task AddEffortValues(List<object?> record, WorkItem workItem)
        {
            var childRelType = (childRelationType ?? await GetChildRelationType()).ReferenceName;
            var fieldNames = GetTaskFieldReferenceNames();
            var wis = await WitClient.GetWorkItemsAsync(GetLinkedWorkItemIds(workItem, childRelType), null, null, WorkItemExpand.Fields);
            var tasks = wis
                .Where(p => p.Fields.ContainsKey(Activity) && p.Fields.ContainsKey(WorkItemType) && p.Fields[WorkItemType] as string == Task)
                .Select(p => new Effort
                {
                    Activity = p.Fields[Activity] as string ?? string.Empty,
                    OriginalEstimate = p.Fields.ContainsKey(OriginalEstimate) ? p.Fields[OriginalEstimate] as double? ?? 0 : 0,
                    RemainingWork = p.Fields.ContainsKey(RemainingWork) ? p.Fields[RemainingWork] as double? ?? 0 : 0,
                    CompletedWork = p.Fields.ContainsKey(CompletedWork) ? p.Fields[CompletedWork] as double? ?? 0 : 0,
                })
                .GroupBy(p => p.Activity)
                .Select(p => new Effort
                {
                    Activity = p.Key,
                    OriginalEstimate = p.Sum(q => q.OriginalEstimate),
                    RemainingWork = p.Sum(q => q.RemainingWork),
                    CompletedWork = p.Sum(q => q.CompletedWork),
                })
                .ToList();
            record.AddRange(new object[] { tasks.Sum(p => p.OriginalEstimate), tasks.Sum(p => p.RemainingWork), tasks.Sum(p => p.CompletedWork) });
            foreach (var activity in (activityCollection ?? await GetOrderedActivityList()).Activities)
            {
                var query = tasks.Where(p => p.Activity == activity);
                if (query.Any())
                {
                    var effort = query.Single();
                    record.AddRange(new object[] { effort.OriginalEstimate, effort.RemainingWork, effort.CompletedWork });
                }
                else
                {
                    record.AddRange(new object[] { 0, 0, 0 });
                }
            }
        }

        /// <summary>
        /// Gets the type of the child relation.
        /// </summary>
        /// <returns>WorkItemRelationType.</returns>
        /// <autogeneratedoc/>
        private async Task<WorkItemRelationType> GetChildRelationType()
        {
            return childRelationType ??= await WitClient.GetRelationTypeAsync(LinkTypes.Child);
        }

        /// <summary>
        /// Gets the linked work item ids.
        /// </summary>
        /// <param name="workItem">The work item.</param>
        /// <param name="relationType">Type of the relation.</param>
        /// <returns>List&lt;System.Int32&gt;.</returns>
        /// <exception cref="DevOpsRemainingQuery.DevOps.InvalidWorkItemUrlException">
        /// The work item url.
        /// </exception>
        private List<int> GetLinkedWorkItemIds(WorkItem workItem, string relationType)
        {
            var list = new List<int>();
            foreach (string url in workItem
                                    .Relations
                                    .Where(p => p.Rel == relationType)
                                    .Select(p => p.Url))
            {
                try
                {
                    list.Add(Convert.ToInt32(url
                                                .Split('/')
                                                .LastOrDefault()));
                }
                catch (Exception e)
                {
                    throw new InvalidWorkItemUrlException(url, e);
                }
            }

            return list;
        }

        /// <summary>
        /// Gets the ordered activity list.
        /// </summary>
        /// <returns>ActivityCollection.</returns>
        /// <autogeneratedoc/>
        private async Task<ActivityCollection> GetOrderedActivityList()
        {
            return activityCollection ??= new ActivityCollection(activityOrder, (await WitClient.GetWorkItemTypeFieldWithReferencesAsync(Project.Id, Task, Activity, WorkItemTypeFieldsExpandLevel.AllowedValues)).AllowedValues.Where(p => (p as string) != null).Select(p => (string)p));
        }

        /// <summary>
        /// Gets the type of the parent relation.
        /// </summary>
        /// <returns>WorkItemRelationType.</returns>
        /// <autogeneratedoc/>
        private async Task<WorkItemRelationType> GetParentRelationType()
        {
            return parentRelationType ??= await WitClient.GetRelationTypeAsync(LinkTypes.Parent);
        }
    }
}