namespace DevOpsRemainingQuery
{
    using System;
    using System.Collections.Generic;
    using System.CommandLine.Invocation;
    using System.CommandLine.Rendering;
    using System.CommandLine.Rendering.Views;
    using System.IO;
    using System.Threading.Tasks;

    using DevOpsRemainingQuery.DevOps;

    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.Logging;

    /// <summary>
    /// Class QueryCommandHandler. Implements the <see cref="System.CommandLine.Invocation.ICommandHandler"/>.
    /// </summary>
    /// <seealso cref="System.CommandLine.Invocation.ICommandHandler"/>
    /// <autogeneratedoc/>
    internal class QueryCommandHandler : ICommandHandler
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="QueryCommandHandler"/> class.
        /// </summary>
        /// <param name="serviceProvider">The service provider.</param>
        /// <param name="options">The options.</param>
        /// <exception cref="ArgumentNullException">serviceProvider.</exception>
        /// <exception cref="ArgumentNullException">options.</exception>
        /// <autogeneratedoc/>
        public QueryCommandHandler(IServiceProvider serviceProvider, QueryCommandOptions options)
        {
            ServiceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
            ConsoleRenderer = serviceProvider.GetRequiredService<ConsoleRenderer>();
            Logger = serviceProvider.GetRequiredService<ILogger<QueryCommandHandler>>();
            Options = options ?? throw new ArgumentNullException(nameof(options));
        }

        /// <summary>
        /// Gets the console renderer.
        /// </summary>
        /// <value>The console renderer.</value>
        /// <autogeneratedoc/>
        protected ConsoleRenderer ConsoleRenderer { get; }

        /// <summary>
        /// Gets the logger.
        /// </summary>
        /// <value>The logger.</value>
        /// <autogeneratedoc/>
        protected ILogger<QueryCommandHandler> Logger { get; }

        /// <summary>
        /// Gets the options.
        /// </summary>
        /// <value>The options.</value>
        /// <autogeneratedoc/>
        protected QueryCommandOptions Options { get; }

        /// <summary>
        /// Gets the service provider.
        /// </summary>
        /// <value>The service provider.</value>
        /// <autogeneratedoc/>
        protected IServiceProvider ServiceProvider { get; }

        /// <summary>
        /// invoke as an asynchronous operation.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <returns>System.Int32.</returns>
        /// <exception cref="ArgumentException">Console property is null - context.</exception>
        /// <exception cref="FileNotFoundException">File name not defined.</exception>
        /// <autogeneratedoc/>
        public async Task<int> InvokeAsync(InvocationContext context)
        {
            var view = new QueryCommandView(Options);
            view.Initialize();
            _ = context.Console ?? throw new ArgumentException("Console property is null", nameof(context));
            using var screen = new ScreenView(ConsoleRenderer, context.Console)
            {
                Child = view,
            };
            screen.Render();
            try
            {
                using Server server = new Server(Options.Server ?? string.Empty, Options.PersonalAccessToken ?? string.Empty);
                server.Connect();
                var project = new Project(server, Options.Project ?? string.Empty);
                var id = project.Id;
                using var query = new EffortQuery(project, Options.Query ?? string.Empty, Options.ActivityOrder ?? new List<string>());
                var export = new Export(query);
                await export.ToFile(Options.OutputFile ?? throw new FileNotFoundException("File name not defined."));
            }
            catch (Exception e)
            {
                Exception? inner = e;
                string message = e.Message;
                while ((inner = inner.InnerException) != null)
                {
                    message += "\n" + e.Message;
                }

                Logger.LogError(0, e, message);
                throw;
            }

            return 0;
        }
    }
}